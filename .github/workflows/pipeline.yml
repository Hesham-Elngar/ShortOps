name: Full CI/CD Pipeline

on:
  workflow_dispatch:
  push:
    branches:
      - dev
      - staging
      - main
      - prod
  pull_request:
    branches:
      - main
      - prod


env:
  AWS_REGION: eu-west-1
  AWS_ACCOUNT_ID: 488639172982
  
jobs:

  build:
    name: Build falsk-app
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

  test:
    name: Test flask-app
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
      - name: Run tests
        run: |
          pytest backend/tests | true        

  #################################################
  # 1️⃣ Setup: generate tag, configure AWS, yq   #
  #################################################
  setup:
    name: Setup environment
    needs: test  
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.version.outputs.new_tag }}
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          
      - name: Debug environment variables
        run: |
          echo "AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
          echo "AWS_REGION: $AWS_REGION"
      - name: Generate Docker image tag
        id: version
        uses: ./.github/actions/generate-tag

      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/ecrAccessRole
          aws-region: ${{ env.AWS_REGION }}
          
  ##################################
  # 2️⃣ Backend-Containerization   #
  ##################################
  Backend-Containerization:
    name: Backend-Containerization
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      # - name: Login to ECR
      #   uses: ./.github/actions/aws-setup
      #   with:
      #     aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
      #     aws-region: ${{ env.AWS_REGION }}
      #     ecr-login: true

      # - name: Build and Push Backend
      #   run: |
      #     IMAGE=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:${{ needs.setup.outputs.new_tag }}
      #     docker build -t $IMAGE ./backend
      #     docker tag $IMAGE ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest
      #     docker push $IMAGE
      #     docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest

   ##################################
   # 3️⃣  Frontend-Containerization  #
   ##################################
  Frontend-Containerization:
    name: Frontend-Containerization
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      # - name: Login to ECR
      #   uses: ./.github/actions/aws-setup
      #   with:
      #     aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
      #     aws-region: ${{ env.AWS_REGION }}
      #     ecr-login: true

      # - name: Build frontend Docker image
      #   run: |
      #     IMAGE=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:${{ needs.setup.outputs.new_tag }}
      #     docker build -t $IMAGE ./frontend
      #     docker tag $IMAGE ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest
      #     docker push $IMAGE
      #     docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest

  image-scan:
    name: Scan Docker images
    runs-on: ubuntu-latest
    needs: [Frontend-Containerization, Backend-Containerization]
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Login to ECR
        uses: ./.github/actions/aws-setup
        with:
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          aws-region: ${{ env.AWS_REGION }}
          ecr-login: true

      - name: Scan Backend Image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest

      - name: Scan Frontend Image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest
  ###############################
  # 6️⃣ Deploy to Dev (EC2)      #
  ###############################
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
      id-token: write
      contents: read
    if: github.ref == 'refs/heads/dev'
    steps:
      - uses: actions/checkout@v4
 
      - name: Login to ECR
        uses: ./.github/actions/aws-setup
        with:
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          aws-region: ${{ env.AWS_REGION }}
          ecr-login: true
          
      - name: SSH & Deploy
        run: |
          echo "${{ secrets.DEV_EC2_SSH_KEY }}" > key.pem
          chmod 600 key.pem
          
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DEV_EC2_HOST }} >> ~/.ssh/known_hosts
      
          ssh -i key.pem ec2-user@${{ secrets.DEV_EC2_HOST }} << EOF   
          mkdir -p /home/ec2-user/url-shortener
          cd /home/ec2-user/url-shortener

          cat > .env << EOT
          ${{ secrets.DOT_ENV }}
          EOT
          
          cat > docker-compose.yml << EOT
          ${{ secrets.DOCKER_COMPOSE_YML }}
          EOT
          
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

          docker-compose pull
          docker-compose up -d --remove-orphans
          docker ps
          EOF
                
          rm -f key.pem


  ################################
  # 7️⃣ Deploy to Staging (EKS)  #
  ################################
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
          id-token: write
          contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/eksAccessRole
          aws-region: ${{ env.AWS_REGION }}
          
      # # Configure AWS & login to ECR if needed
      # - name: Login to ECR
      #   uses: ./.github/actions/aws-setup
      #   with:
      #     aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
      #     aws-region: ${{ env.AWS_REGION }}
      #     ecr-login: true
  
      # Update kubeconfig so kubectl can talk to your EKS cluster
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
  
      # Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'
  
      # Install Helm
      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'
          
      # create namespace 
      - name: create namespace
        run: |
          if ! kubectl get ns staging; then 
          kubectl create ns staging
          fi
          
      # Deploy Helm chart
      - name: Deploy Helm
        run: |
          helm upgrade --install url-shortener ./helm \
            -f ./helm/values.yaml \
            -n staging
  
      # Optional: Verify Deployment
      - name: Check pods
        run: kubectl get pods -n staging
       
  ##################################
  # 8️⃣  Deploy to Production       #
  ##################################
  deploy-prod:
    name: Deploy to Production (ArgoCD)
    runs-on: ubuntu-latest
    needs: image-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/prod'
    steps:
      - uses: actions/checkout@v4
      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd

      - name: Test CLI
        run: argocd version --client

      - name:  ArgoCD Sync
        run: |
          argocd login ${{ secrets.ARGOCD_SERVER }} \
            --username ${{ secrets.ARGOCD_USERNAME }} \
            --password ${{ secrets.ARGOCD_TOKEN }} \
            --insecure

          argocd app sync url-shortener
          argocd app wait url-shortener
        
