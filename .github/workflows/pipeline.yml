name: Full CI/CD Pipeline

on:
  workflow_dispatch:
  push:
    branches:
      - dev
      - staging
      - main
      - prod
  pull_request:
    branches:
      - main
     # - prod

env:
  AWS_REGION: eu-west-1
  AWS_ACCOUNT_ID: 488639172982
  
jobs:

  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

  test:
    name: Test 
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
      - name: Run tests
        run: |
          pytest backend/tests | true        

  #################################################
  # 1ï¸âƒ£ Setup: generate tag, configure AWS, yq   #
  #################################################
  setup:
    name: Setup environment
    needs: test  
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.version.outputs.new_tag }}
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          
      - name: Debug environment variables
        run: |
          echo "AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
          echo "AWS_REGION: $AWS_REGION"
      - name: Generate Docker image tag
        id: version
        uses: ./.github/actions/generate-tag

      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/ecrAccessRole
          aws-region: ${{ env.AWS_REGION }}
          
  ##################################
  # 2ï¸âƒ£ Backend-Containerization   #
  ##################################
  Backend-Containerization:
    name: Backend-Containerization
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Login to ECR
        uses: ./.github/actions/aws-setup
        with:
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          aws-region: ${{ env.AWS_REGION }}
          ecr-login: true

      - name: Build and Push Backend
        run: |
          IMAGE=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:${{ needs.setup.outputs.new_tag }}
          docker build -t $IMAGE ./backend
          docker tag $IMAGE ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest
          docker push $IMAGE
          docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest

   ##################################
   # 3ï¸âƒ£  Frontend-Containerization  #
   ##################################
  Frontend-Containerization:
    name: Frontend-Containerization
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Login to ECR
        uses: ./.github/actions/aws-setup
        with:
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          aws-region: ${{ env.AWS_REGION }}
          ecr-login: true

      - name: Build frontend Docker image
        run: |
          IMAGE=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:${{ needs.setup.outputs.new_tag }}
          docker build -t $IMAGE ./frontend
          docker tag $IMAGE ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest
          docker push $IMAGE
          docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest

  image-scan:
    name: Scan Docker images
    runs-on: ubuntu-latest
    needs: [Frontend-Containerization, Backend-Containerization]
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Login to ECR
        uses: ./.github/actions/aws-setup
        with:
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          aws-region: ${{ env.AWS_REGION }}
          ecr-login: true

      - name: Scan Backend Image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest

      - name: Scan Frontend Image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest
  ###############################
  # 6ï¸âƒ£ Deploy to Dev (EC2)      #
  ###############################
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
      id-token: write
      contents: read
    if: github.ref == 'refs/heads/dev'
    steps:
      - uses: actions/checkout@v4
 
      - name: Login to ECR
        uses: ./.github/actions/aws-setup
        with:
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          aws-region: ${{ env.AWS_REGION }}
          ecr-login: true
          
      - name: SSH & Deploy
        run: |
          echo "${{ secrets.DEV_EC2_SSH_KEY }}" > key.pem
          chmod 600 key.pem
          
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DEV_EC2_HOST }} >> ~/.ssh/known_hosts
      
          ssh -i key.pem ec2-user@${{ secrets.DEV_EC2_HOST }} << EOF   
          mkdir -p /home/ec2-user/url-shortener
          cd /home/ec2-user/url-shortener

          cat > .env << EOT
          ${{ secrets.DOT_ENV }}
          EOT
          
          cat > docker-compose.yml << EOT
          ${{ secrets.DOCKER_COMPOSE_YML }}
          EOT
          
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

          docker-compose pull
          docker-compose up -d --remove-orphans
          docker ps
          EOF
                
          rm -f key.pem


  ################################
  # 7ï¸âƒ£ Deploy to Staging (EKS)  #
  ################################
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
          id-token: write
          contents: read
    if: github.ref == 'refs/heads/staging'      
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/eksAccessRole
          aws-region: ${{ env.AWS_REGION }}
  
      # Update kubeconfig so kubectl can talk to your EKS cluster
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
  
      # Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'
  
      # Install Helm
      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'
          
      # create namespace 
      - name: create namespace
        run: |
          if ! kubectl get ns staging; then 
          kubectl create ns staging
          fi
          
      # Deploy Helm chart
      - name: Deploy Helm
        run: |
          helm upgrade --install url-shortener ./helm \
            -f ./helm/values.yaml \
            -n staging
  
      # Optional: Verify Deployment
      - name: Check resources
        run: |
          sleep 5
          kubectl get all -n staging
       
  ##################################
  # 8ï¸âƒ£  Deploy to Production       #
  ##################################        
  deploy-prod:
    name: Deploy to Production (ArgoCD in EKS)
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
      id-token: write
      contents: read
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/prod'
    steps:
      - uses: actions/checkout@v4
  
      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/eksAccessRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
  
      # Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'
  
      # Install Helm
      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'
          
      # Install ArgoCD in EKS
      - name: Install ArgoCD in EKS
        run: |
          # Check if ArgoCD already exists
          if kubectl get ns argocd 2>/dev/null; then
            echo "âœ… ArgoCD namespace already exists"
            # Update ArgoCD if needed
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          else
            echo "ðŸš€ Installing ArgoCD..."
            kubectl create namespace argocd
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          fi
          
          # Wait for ArgoCD server to be ready
          echo "â³ Waiting for ArgoCD to start..."
          kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s
          
          # Get admin password
          echo "ðŸ” ArgoCD admin password:"
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
          echo ""
          
      # Create prod namespace and ECR credentials
      - name: Setup prod namespace
        run: |
          # Create namespace
          kubectl create namespace prod --dry-run=client -o yaml | kubectl apply -f -
          
          # Create ECR secret for image pulling
          kubectl delete secret ecr-registry -n prod --ignore-not-found
          kubectl create secret docker-registry ecr-registry \
            --docker-server=488639172982.dkr.ecr.eu-west-1.amazonaws.com \
            --docker-username=AWS \
            --docker-password=$(aws ecr get-login-password --region eu-west-1) \
            --namespace=prod --dry-run=client -o yaml | kubectl apply -f -
          
      # Create/Update ArgoCD Application
      - name: Create ArgoCD Application
        run: |
          cat > argocd-application.yaml <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: url-shortener
            namespace: argocd
          spec:
            project: default
            source:
              repoURL: 'https://github.com/Hesham-Elngar/ShortOps.git'
              targetRevision: prod
              path: helm
              helm:
                valueFiles:
                  - values.yaml
            destination:
              server: 'https://kubernetes.default.svc'
              namespace: prod
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
          EOF
          
          # Apply the application
          kubectl apply -f argocd-application.yaml
          
          echo "âœ… ArgoCD application created/updated"
          
      # Trigger and monitor sync
      - name: Trigger and Monitor ArgoCD Sync
        run: |
          # Start port-forward to access ArgoCD API
          echo "ðŸ”Œ Starting port-forward to ArgoCD API..."
          kubectl port-forward svc/argocd-server -n argocd 8080:443 &
          PORT_FORWARD_PID=$!
          sleep 5
          
          # Get ArgoCD admin password
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          
          # Get JWT token
          echo "ðŸ” Getting authentication token..."
          JWT_RESPONSE=$(curl -k -s -X POST https://localhost:8080/api/v1/session \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"admin\",\"password\":\"$ARGOCD_PASSWORD\"}")
          
          JWT_TOKEN=$(echo "$JWT_RESPONSE" | jq -r '.token')
          
          if [ -z "$JWT_TOKEN" ] || [ "$JWT_TOKEN" = "null" ]; then
            echo "âŒ Failed to get JWT token"
            echo "Response: $JWT_RESPONSE"
            kill $PORT_FORWARD_PID
            exit 1
          fi
          
          echo "âœ… Authenticated with ArgoCD"
          
          # Trigger sync
          echo "ðŸ”„ Triggering sync..."
          SYNC_RESPONSE=$(curl -k -s -X POST https://localhost:8080/api/v1/applications/url-shortener/sync \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{}')
          
          echo "âœ… Sync initiated"
          
          # Monitor sync progress
          echo ""
          echo "ðŸ“Š DEPLOYMENT STATUS"
          echo "==================="
          
          for i in {1..60}; do  # Increased to 60 attempts (10 minutes)
            # Get application status
            APP_DATA=$(curl -k -s https://localhost:8080/api/v1/applications/url-shortener \
              -H "Authorization: Bearer $JWT_TOKEN")
            
            SYNC_STATUS=$(echo "$APP_DATA" | jq -r '.status.sync.status // "Unknown"')
            HEALTH_STATUS=$(echo "$APP_DATA" | jq -r '.status.health.status // "Unknown"')
            
            printf "[%s] Attempt %2d/60 | Sync: %-10s | Health: %-10s\n" \
              "$(date +%H:%M:%S)" "$i" "$SYNC_STATUS" "$HEALTH_STATUS"
            
            if [ "$SYNC_STATUS" = "Synced" ]; then
              echo ""
              echo "ðŸŽ‰ DEPLOYMENT SUCCESSFUL"
              echo "Sync: $SYNC_STATUS"
              echo "Health: $HEALTH_STATUS"
              
              # Kill port-forward
              kill $PORT_FORWARD_PID
              exit 0
            fi
            
            sleep 10
          done
          
          echo ""
          echo "â° DEPLOYMENT TIMED OUT (10 minutes)"
          
          # Show final pod status
          echo ""
          echo "ðŸ“¦ Final pod status in prod namespace:"
          kubectl get pods -n prod
          
          # Kill port-forward
          kill $PORT_FORWARD_PID
          exit 1
