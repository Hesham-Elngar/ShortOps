name: Full CI/CD Pipeline

on:
  workflow_dispatch:
  push:
    branches:
      - dev
      - staging
      - main
      - prod
  pull_request:
    branches:
      - main
      - prod


env:
  AWS_REGION: eu-west-1
  AWS_ACCOUNT_ID: 488639172982
  
jobs:

  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # - name: Set up Python
      #   uses: actions/setup-python@v4
      #   with:
      #     python-version: '3.9'
      # - name: Install dependencies
      #   run: |
      #     python -m pip install --upgrade pip
      #     pip install -r backend/requirements.txt

  test:
    name: Test 
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      # - name: Set up Python
      #   uses: actions/setup-python@v4
      #   with:
      #     python-version: '3.9'
      # - name: Install dependencies
      #   run: |
      #     python -m pip install --upgrade pip
      #     pip install -r backend/requirements.txt
      # - name: Run tests
      #   run: |
      #     pytest backend/tests | true        

  #################################################
  # 1Ô∏è‚É£ Setup: generate tag, configure AWS, yq   #
  #################################################
  setup:
    name: Setup environment
    needs: test  
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.version.outputs.new_tag }}
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          
      - name: Debug environment variables
        run: |
          echo "AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
          echo "AWS_REGION: $AWS_REGION"
      - name: Generate Docker image tag
        id: version
        uses: ./.github/actions/generate-tag

      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/ecrAccessRole
          aws-region: ${{ env.AWS_REGION }}
          
  ##################################
  # 2Ô∏è‚É£ Backend-Containerization   #
  ##################################
  Backend-Containerization:
    name: Backend-Containerization
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      # - name: Login to ECR
      #   uses: ./.github/actions/aws-setup
      #   with:
      #     aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
      #     aws-region: ${{ env.AWS_REGION }}
      #     ecr-login: true

      # - name: Build and Push Backend
      #   run: |
      #     IMAGE=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:${{ needs.setup.outputs.new_tag }}
      #     docker build -t $IMAGE ./backend
      #     docker tag $IMAGE ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest
      #     docker push $IMAGE
      #     docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest

   ##################################
   # 3Ô∏è‚É£  Frontend-Containerization  #
   ##################################
  Frontend-Containerization:
    name: Frontend-Containerization
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      # - name: Login to ECR
      #   uses: ./.github/actions/aws-setup
      #   with:
      #     aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
      #     aws-region: ${{ env.AWS_REGION }}
      #     ecr-login: true

      # - name: Build frontend Docker image
      #   run: |
      #     IMAGE=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:${{ needs.setup.outputs.new_tag }}
      #     docker build -t $IMAGE ./frontend
      #     docker tag $IMAGE ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest
      #     docker push $IMAGE
      #     docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest

  image-scan:
    name: Scan Docker images
    runs-on: ubuntu-latest
    needs: [Frontend-Containerization, Backend-Containerization]
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      # - name: Login to ECR
      #   uses: ./.github/actions/aws-setup
      #   with:
      #     aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
      #     aws-region: ${{ env.AWS_REGION }}
      #     ecr-login: true

      # - name: Scan Backend Image
      #   uses: aquasecurity/trivy-action@master
      #   with:
      #     image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-backend:latest

      # - name: Scan Frontend Image
      #   uses: aquasecurity/trivy-action@master
      #   with:
      #     image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener-frontend:latest
  ###############################
  # 6Ô∏è‚É£ Deploy to Dev (EC2)      #
  ###############################
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
      id-token: write
      contents: read
    if: github.ref == 'refs/heads/dev'
    steps:
      - uses: actions/checkout@v4
 
      - name: Login to ECR
        uses: ./.github/actions/aws-setup
        with:
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          aws-region: ${{ env.AWS_REGION }}
          ecr-login: true
          
      - name: SSH & Deploy
        run: |
          echo "${{ secrets.DEV_EC2_SSH_KEY }}" > key.pem
          chmod 600 key.pem
          
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DEV_EC2_HOST }} >> ~/.ssh/known_hosts
      
          ssh -i key.pem ec2-user@${{ secrets.DEV_EC2_HOST }} << EOF   
          mkdir -p /home/ec2-user/url-shortener
          cd /home/ec2-user/url-shortener

          cat > .env << EOT
          ${{ secrets.DOT_ENV }}
          EOT
          
          cat > docker-compose.yml << EOT
          ${{ secrets.DOCKER_COMPOSE_YML }}
          EOT
          
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

          docker-compose pull
          docker-compose up -d --remove-orphans
          docker ps
          EOF
                
          rm -f key.pem


  ################################
  # 7Ô∏è‚É£ Deploy to Staging (EKS)  #
  ################################
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
          id-token: write
          contents: read
    if: github.ref == 'refs/heads/staging'      
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/eksAccessRole
          aws-region: ${{ env.AWS_REGION }}
  
      # Update kubeconfig so kubectl can talk to your EKS cluster
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
  
      # Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'
  
      # Install Helm
      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'
          
      # create namespace 
      - name: create namespace
        run: |
          if ! kubectl get ns staging; then 
          kubectl create ns staging
          fi
          
      # Deploy Helm chart
      - name: Deploy Helm
        run: |
          helm upgrade --install url-shortener ./helm \
            -f ./helm/values.yaml \
            -n staging
  
      # Optional: Verify Deployment
      - name: Check resources
        run: |
          sleep 5
          kubectl get all -n staging
       
  ##################################
  # 8Ô∏è‚É£  Deploy to Production       #
  ##################################        
  deploy-prod:
    name: Deploy to Production (ArgoCD)
    runs-on: ubuntu-latest
    needs: image-scan
    permissions:
      id-token: write
      contents: read
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/prod'
    steps:
      - uses: actions/checkout@v4

      - name: Install ArgoCD CLI v2 (NOT Core)
        run: |
          # Download ArgoCD v2 CLI
          VERSION="v2.9.4"  # Use latest v2 version
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/$VERSION/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/
          argocd version --client
            # Update kubeconfig so kubectl can talk to your EKS cluster
      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/eksAccessRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
  
      # Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'
  
      # Install Helm
      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'
          
      # create namespace 
      - name: create namespace
        run: |
          if ! kubectl get ns prod; then 
          kubectl create ns prod
          fi
          
      # Deploy Helm chart
      - name: Deploy Helm
        run: |
          helm upgrade --install url-shortener ./helm \
            -f ./helm/values.yaml \
            -n prod
  

      - name: Deploy Application
        env:
          ARGOCD_URL: ${{ secrets.ARGOCD_URL }}
          ARGOCD_PASS: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          # 1. Authenticate
          echo "üîê Authenticating..."
          AUTH_RESPONSE=$(curl -k -s -X POST $ARGOCD_URL/api/v1/session \
            -d "{\"username\":\"admin\",\"password\":\"$ARGOCD_PASS\"}" \
            -H "Content-Type: application/json")
          
          # Check if we got a valid response
          if ! echo "$AUTH_RESPONSE" | jq -e '.token' > /dev/null 2>&1; then
            echo "‚ùå Authentication failed"
            echo "Response: $AUTH_RESPONSE"
            exit 1
          fi
          
          TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.token')
          echo "‚úÖ Authenticated"
          
          # 2. Trigger sync
          echo "üîÑ Triggering sync..."
          SYNC_RESPONSE=$(curl -k -s -X POST $ARGOCD_URL/api/v1/applications/url-shortener/sync \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{}')
          
          echo "‚úÖ Sync initiated"
          
          # 3. Monitor
          echo ""
          echo "üìä DEPLOYMENT STATUS"
          echo "==================="
          
          for i in {1..30}; do
            # Get app status
            APP_DATA=$(curl -k -s $ARGOCD_URL/api/v1/applications/url-shortener \
              -H "Authorization: Bearer $TOKEN")
            
            # Extract status
            SYNC_STATUS=$(echo "$APP_DATA" | jq -r '.status.sync.status // "Unknown"')
            HEALTH_STATUS=$(echo "$APP_DATA" | jq -r '.status.health.status // "Unknown"')
            
            # Display
            printf "[%s] Attempt %2d/30 | Sync: %-10s | Health: %-10s\n" \
              "$(date +%H:%M:%S)" "$i" "$SYNC_STATUS" "$HEALTH_STATUS"
            
            # Check if sync completed
            if [ "$SYNC_STATUS" = "Synced" ]; then
              echo ""
              echo "üéâ DEPLOYMENT SUCCESSFUL"
              echo "Sync: $SYNC_STATUS"
              echo "Health: $HEALTH_STATUS"
              exit 0
            fi
            
            sleep 10
          done
          
          echo ""
          echo "‚è∞ DEPLOYMENT TIMED OUT"
          exit 1
